pipeline {
    agent any

    environment {
        AWS_REGION = 'us-east-1'
        EKS_CLUSTER = 'springboot-cluster'
        AWS_ACCOUNT_ID = '975373241855'
        DOCKER_IMAGE = 'addressbook-app'
        VERSION = 'latest'
        S3_BUCKET = 'my-springbootapp-bucket'
        ECR_REGISTRY = "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
        ECR_REPO = "${ECR_REGISTRY}/${DOCKER_IMAGE}"
        SERVICE_NAME = 'addressbook-service'
        K8S_NAMESPACE = 'default'
    }

    options {
        timeout(time: 30, unit: 'MINUTES')
    }

    stages {
        stage('Clone Repository') {
            steps {
                git url: 'https://github.com/vivekbhaskar746/addressbook-deploymnet.git', branch: 'main'
            }
        }

        stage('Build with Maven') {
            steps {
                sh 'chmod +x mvnw || true'
                sh './mvnw clean package -Dmaven.test.skip=true'
            }
        }

        stage('Archive Artifact') {
            steps {
                archiveArtifacts artifacts: '**/target/*.jar', fingerprint: true
            }
        }

        stage('Build Docker Image') {
            steps {
                sh "docker build -t ${DOCKER_IMAGE}:${VERSION} ."
            }
        }

        stage('Push to ECR') {
            steps {
                withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-credentials-id']]) {
                    sh '''
                    set -e
                    aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $ECR_REGISTRY

                    if ! aws ecr describe-repositories --repository-names $DOCKER_IMAGE > /dev/null 2>&1; then
                      aws ecr create-repository --repository-name $DOCKER_IMAGE
                    fi

                    docker tag $DOCKER_IMAGE:$VERSION $ECR_REPO:$VERSION
                    docker push $ECR_REPO:$VERSION
                    '''
                }
            }
        }

        stage('Deploy to EKS') {
            steps {
                withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-credentials-id']]) {
                    sh '''
                    export KUBECONFIG=$(mktemp)
                    aws eks --region $AWS_REGION update-kubeconfig --name $EKS_CLUSTER --kubeconfig $KUBECONFIG

                    kubectl --kubeconfig $KUBECONFIG apply -f k8s/deployment.yml
                    kubectl --kubeconfig $KUBECONFIG apply -f k8s/service.yml
                    kubectl --kubeconfig $KUBECONFIG apply -f my-sqldeployment.yml
                    '''
                }
            }
        }

        stage('Smoke Test') {
            steps {
                withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-credentials-id']]) {
                    script {
                        sh '''
                        export KUBECONFIG=$(mktemp)
                        aws eks --region $AWS_REGION update-kubeconfig --name $EKS_CLUSTER --kubeconfig $KUBECONFIG
                        echo "Running smoke test..."

                        for i in $(seq 1 10); do
                          HOST=$(kubectl --kubeconfig $KUBECONFIG get svc $SERVICE_NAME -n $K8S_NAMESPACE -o jsonpath="{.status.loadBalancer.ingress[0].hostname}" 2>/dev/null)
                          if [ -n "$HOST" ]; then
                            echo "LoadBalancer hostname: $HOST"
                            break
                          fi
                          echo "Waiting for LoadBalancer IP... ($i)"
                          sleep 30
                        done

                        if [ -z "$HOST" ]; then
                          echo "LoadBalancer hostname not available. Smoke test failed."
                          exit 1
                        fi

                        curl -sSf http://$HOST:80/actuator/health | grep '"status":"UP"' || {
                          echo "Smoke test failed: Health endpoint did not return UP"
                          exit 1
                        }
                        '''
                    }
                }
            }
        }
    }

    post {
        success {
            echo '✅ Pipeline completed successfully.'
        }
        failure {
            echo '❌ Pipeline failed. Check logs for details.'
        }
        always {
            withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-credentials-id']]) {
                sh '''
                export KUBECONFIG=$(mktemp)
                aws eks --region $AWS_REGION update-kubeconfig --name $EKS_CLUSTER --kubeconfig $KUBECONFIG

                echo "Pipeline completed at $(date)" > pipeline.log
                echo "Pods status:" >> pipeline.log
                kubectl --kubeconfig $KUBECONFIG get pods -n $K8S_NAMESPACE >> pipeline.log
                echo "Service status:" >> pipeline.log
                kubectl --kubeconfig $KUBECONFIG get svc $SERVICE_NAME -n $K8S_NAMESPACE >> pipeline.log

                aws s3 cp pipeline.log s3://$S3_BUCKET/logs/pipeline-$(date +%Y%m%d%H%M%S).log
                '''
            }
        }
    }
}

